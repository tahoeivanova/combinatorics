# import numpy as np

def factorial(n):
    f = 1
    for x in range(1, n+1):
        f *= x
    return f

def C_n_m(n,m):
    return factorial(n)/(factorial(n-m) * factorial(m))

def C_n_m_rep(n,m):
    return factorial(n+m-1)/(factorial(n-1)*factorial(m))

def P_rep(n,m): # p repeatable
    add = 1
    for x in m:
        add *= factorial(x) # произведение факториалов всех повторений, порядок не важен
    return factorial(n)/add # делим на сумму повтрений

print('Задача 1')
print('Сколько четырёхзначных чисел можно составить из четырёх цифр 1, 6, 3, 0?')

# рассуждение:
'''
Эта задача на перестановки без поторений - числа 1630,1036, 0361 и т.д.
Сочетания, начинающиеся с 0, не считаются 4-значными числами (т.к. 0361 = 361 - трехзначное число)
Цифры не потворяются (не ищем варианты 1111 и т.д.)
'''
# ход решения:
res_1 = factorial(3) # способами можно переставить 3 объекта без повторений (то есть тех, к-ые начинаются с 0)

res_2 = factorial(4) # способами можно переставить 4 объекта без повторений

print('Ответ',res_2 - res_1) # вычитаем способы, где в начале 0


print('Задача 2')
print('Сколькими способами из колоды в 36 карт можно выбрать 3 карты?')
# рассуждение:
'''Это задача на сочетания без повторений'''
# ход решения:
res = C_n_m(36, 3)
print(f'{res} способами можно выбрать 3 карты из колоды в 36 карт')

print('Задача 3')
print('На должности менеджера по продажам и его ассистента подали резюме 23 человека.\
Сколькими способами можно выбрать финальных 2-х кандидатов?')

# рассуждение
'''Две должности - менеджер по продажам и ассистент. Всего 23 резюме.
2 финальных кандидата - это сочетание 2-х кандидатов из n'''
res = C_n_m(23, 2)
print(f'{res} способами можно выбрать 2 кандидатов из 23 резюме.')

print('Задача 4')
print('Сколько различных сочетаний можно получить перестановкой букв в словосочетании: \
НУЖНО ЛЮБИТЬ МАТЕМАТИКУ и КОТИКОВ?')
# рассуждение:
'''Задача на сочетания с повторениями'''
phrase = 'НУЖНО ЛЮБИТЬ МАТЕМАТИКУ и КОТИКОВ'.split()

# unique, counts = np.unique([x for x in 'НУЖНО ЛЮБИТЬ МАТЕМАТИКУ и КОТИКОВ'.replace(' ', '')], return_counts=True)
letters = ''.join(phrase)
# print(letters)
letters_list = list(letters)
letters_list_copy = letters_list[:]
# print(letters_list)
letters_set = set(letters)
# print(letters_set)

letters_set_list = list(letters_set)
# print(letters_set_list)

F = [0] * len(letters_set_list) # количество уникальных элементов
# нужно понять, сколько есть повторяющихся букв - буква - и количество
for x in range(len(letters_set_list)):
    for y in range(len(letters_list)):
        if letters_set_list[x] in letters_list:
            F[x]+=1
            letters_list.remove(letters_set_list[x])


print(F)
n = len(letters_set)
print(n)
m = F
print(m)

res = P_rep(n,m)
print(f'Ответ: {res} различных сочетаний')
# result = []
# for i in range(len(letters_set_list)):
#     result += [letters_set_list[i]] * F[i]
#
# print(result)
# print(sorted(result))





print('Задача 5')
print('В кошельке находится  1, 2 и 10 рублевые монеты \
Сколькими способами можно извлечь 4 монеты из кошелька?')

# рассуждения
'''Задача на сочетания с повторениями'''
n = 3
m = 4
res = C_n_m_rep(n,m)
print(f'{res} способами можно выбрать 4 монеты из кошелька.')

print('Задача 6')
print('Сколько существует всего вариантов IPv4 адресов (https://ru.wikipedia.org/wiki/IPv4)?')
# IPv4 использует 32-битные (четырёхбайтные) адреса
# рассуждения
''' сколько может быть различных 32-битных номеров?

'''
res = 2**32
print(f'{res} вариантов IPv4 адресов')

'''XXXX.XXXX.XXXX.XXXX
В десятичной системе в каждом из 4 блоков - от 0 до 256
256(первый блок) * 256(второй блок) * 256(третий блок)* 256(четвертый блок)
'''
m = 256 ** 4
print(f'{m} вариантов IPv4 адресов (в десятичной системе)')
